name: Semantic Release

on:
  push:
    branches: [ main ]
  workflow_dispatch:
    inputs:
      dry_run:
        description: 'Run semantic-release in dry-run mode'
        required: false
        default: 'false'

permissions:
  contents: write
  packages: write
  id-token: write

jobs:
  release:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Setup Node
        uses: actions/setup-node@v4
        with:
          node-version: '18'

      - name: Install dependencies
        run: npm ci

      - name: Fetch GHCR image digests
        id: fetch_digests
        run: |
          set -euo pipefail
          BACKEND_NAME="2024866732/hafjet-bukku-backend"
          FRONTEND_NAME="2024866732/hafjet-bukku-frontend"

          get_digest() {
            OWNER_REPO=$1
            attempts=3
            delay=2
            for i in $(seq 1 $attempts); do
              # Filter out JSON error messages and validate format
              DIGEST=$(gh api -H "Accept: application/vnd.oci.image.manifest.v1+json" \
                "/repos/${OWNER_REPO}/packages/container/${OWNER_REPO##*/}/versions" \
                --jq 'map(select(.metadata.container.tags[]? == "latest"))[0].metadata.container.digest' 2>&1 | \
                grep -v "message" | grep -v "Not Found" | tr -d '\n\r' || echo "")
              # Validate it's actually a sha256 digest
              if [ -n "$DIGEST" ] && [ "$DIGEST" != "null" ] && echo "$DIGEST" | grep -qE '^sha256:[a-f0-9]{64}$'; then
                echo "$DIGEST"
                return 0
              fi

              # Fallback to first entry if no 'latest' tag found
              DIGEST=$(gh api -H "Accept: application/vnd.oci.image.manifest.v1+json" \
                "/repos/${OWNER_REPO}/packages/container/${OWNER_REPO##*/}/versions" \
                --jq '.[0].metadata.container.digest' 2>&1 | \
                grep -v "message" | grep -v "Not Found" | tr -d '\n\r' || echo "")
              # Validate it's actually a sha256 digest
              if [ -n "$DIGEST" ] && [ "$DIGEST" != "null" ] && echo "$DIGEST" | grep -qE '^sha256:[a-f0-9]{64}$'; then
                echo "$DIGEST"
                return 0
              fi
              echo "Attempt $i: GHCR API did not return a digest for ${OWNER_REPO}; retrying in ${delay}s..." >&2
              sleep $delay
              delay=$((delay * 2))
            done

            # Fallback: try to pull and inspect with docker
            IMAGE=ghcr.io/${OWNER_REPO}:latest
            if docker pull "$IMAGE" >/dev/null 2>&1; then
              DIGEST=$(docker image inspect "$IMAGE" --format '{{index .RepoDigests 0}}' 2>/dev/null | grep -oE 'sha256:[a-f0-9]{64}' || echo "")
              if [ -n "$DIGEST" ]; then
                echo "$DIGEST"
                return 0
              fi
            fi

            # Return empty if all attempts fail (not an error - images might not exist yet)
            echo ""
            return 0
          }

          BACKEND_DIGEST=$(get_digest "$BACKEND_NAME")
          FRONTEND_DIGEST=$(get_digest "$FRONTEND_NAME")

          # Ensure clean output - no JSON fragments
          BACKEND_DIGEST=$(echo "$BACKEND_DIGEST" | tr -d '\n\r' | grep -E '^sha256:[a-f0-9]{64}$' || echo "")
          FRONTEND_DIGEST=$(echo "$FRONTEND_DIGEST" | tr -d '\n\r' | grep -E '^sha256:[a-f0-9]{64}$' || echo "")

          echo "BACKEND_DIGEST=$BACKEND_DIGEST" >> $GITHUB_OUTPUT
          echo "FRONTEND_DIGEST=$FRONTEND_DIGEST" >> $GITHUB_OUTPUT
          
          if [ -z "$BACKEND_DIGEST" ]; then
            echo "⚠️ Backend digest not found - image may not be pushed yet"
          else
            echo "✅ Backend digest: $BACKEND_DIGEST"
          fi
          
          if [ -z "$FRONTEND_DIGEST" ]; then
            echo "⚠️ Frontend digest not found - image may not be pushed yet"
          else
            echo "✅ Frontend digest: $FRONTEND_DIGEST"
          fi
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          DOCKER_BUILDKIT: 1

      - name: Write image-metadata artifact
        run: |
          mkdir -p image-metadata
          TIMESTAMP=$(date -u +"%Y-%m-%dT%H:%M:%SZ")
          cat > image-metadata/${{ github.sha }}.json <<EOF
          {
            "github_sha": "${{ github.sha }}",
            "timestamp": "${TIMESTAMP}",
            "backend": { "digest": "${{ steps.fetch_digests.outputs.BACKEND_DIGEST }}" },
            "frontend": { "digest": "${{ steps.fetch_digests.outputs.FRONTEND_DIGEST }}" }
          }
          EOF

      - name: Upload image-metadata artifact
        uses: actions/upload-artifact@v4
        with:
          name: image-metadata-${{ github.sha }}
          path: image-metadata/${{ github.sha }}.json

      - name: Run semantic-release
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          BACKEND_DIGEST: ${{ steps.fetch_digests.outputs.BACKEND_DIGEST }}
          FRONTEND_DIGEST: ${{ steps.fetch_digests.outputs.FRONTEND_DIGEST }}
        run: |
          if [ "${{ github.event.inputs.dry_run }}" = 'true' ]; then
            echo "Running semantic-release in dry-run mode"
            npx semantic-release --dry-run
          else
            npx semantic-release
          fi

      - name: Append image digests to semantic-release created release
        if: always()
        run: |
          set -euo pipefail
          REPO="${{ github.repository }}"
          BACKEND_DIGEST='${{ steps.fetch_digests.outputs.BACKEND_DIGEST }}'
          FRONTEND_DIGEST='${{ steps.fetch_digests.outputs.FRONTEND_DIGEST }}'

          # Get latest release (semantic-release creates the newest release)
          RELEASE_INFO=$(gh api repos/$REPO/releases --jq '.[0]')
          if [ -z "$RELEASE_INFO" ] || [ "$RELEASE_INFO" = "null" ]; then
            echo "No releases found to edit" && exit 0
          fi

          TAG_NAME=$(echo "$RELEASE_INFO" | jq -r '.tag_name')
          EXISTING_BODY=$(gh release view "$TAG_NAME" --repo "$REPO" --json body -q '.body' || echo "")

          NEW_BODY="$EXISTING_BODY\n\n"
          if [ -n "$BACKEND_DIGEST" ]; then
            NEW_BODY+="### Backend image\n$BACKEND_DIGEST\n\n"
          fi
          if [ -n "$FRONTEND_DIGEST" ]; then
            NEW_BODY+="### Frontend image\n$FRONTEND_DIGEST\n\n"
          fi

          echo "Updating release $TAG_NAME with image digests"
          gh release edit "$TAG_NAME" --repo "$REPO" --notes "$NEW_BODY"
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
